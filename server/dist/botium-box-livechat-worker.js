!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("path"),require("uuid/v1"),require("child_process"),require("lodash"),require("ioredis"),require("better-queue"),require("debug"),require("util"),require("botium-core")):"function"==typeof define&&define.amd?define(["path","uuid/v1","child_process","lodash","ioredis","better-queue","debug","util","botium-core"],t):e.main=t(e.path,e.v1,e.child_process,e.lodash,e.ioredis,e.betterQueue,e.debug,e.util,e.botiumCore)}(this,function(e,t,s,n,a,r,o,i,c){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,t=t&&t.hasOwnProperty("default")?t.default:t,s=s&&s.hasOwnProperty("default")?s.default:s,n=n&&n.hasOwnProperty("default")?n.default:n,a=a&&a.hasOwnProperty("default")?a.default:a,r=r&&r.hasOwnProperty("default")?r.default:r,o=o&&o.hasOwnProperty("default")?o.default:o,i=i&&i.hasOwnProperty("default")?i.default:i,c=c&&c.hasOwnProperty("default")?c.default:c;const u=s.fork,S=o("botium-box-server-livechat"),d=o("botium-box-server-livechat-worker"),p=c.BotDriver,l=process.env.BOTIUMBOX_LIVECHAT_IDLE_TIMEOUT||3e5,E={},O={},v=(e,t,s)=>{e.send({type:t,message:s})},T=({conversationId:e,queueSettings:t,pubsub:s})=>{O[e]&&clearTimeout(O[e]),O[e]=setTimeout(async()=>{const n=new a(t.redis);S(`Auto cleanup of conversation ${e} after ${l}ms idle time`),I(e),await n.del(e),s.publish(e,{liveChatConvoStepAdded:{err:`Automatically closed chatbot connection after ${l}ms idle time`}})},l)},I=async e=>{O[e]&&clearTimeout(O[e]),delete O[e];const t=E[e];t&&v(t,f.STOP_CONVERSATION)},h=async({conversationId:e},{queueSettings:t})=>{const s=new a(t.redis),n=await s.get(e);return n&&JSON.parse(n)},_=async(e,t,s)=>{await s.set(e,JSON.stringify(t)),await s.expire(e,l/1e3);const n=await s.ttl(e);S(`updateConversation(${e}) TTL(seconds): ${n}`)},f={USER_SAYS:"USER_SAYS",USER_SAYS_FAILED:"USER_SAYS_FAILED",STOP_CONVERSATION:"STOP_CONVERSATION",STOP_CONVERSATION_FINISHED:"STOP_CONVERSATION_FINISHED",MESSAGE_SENTTOBOT:"MESSAGE_SENTTOBOT",MESSAGE_RECEIVEDFROMBOT:"MESSAGE_RECEIVEDFROMBOT",LOG:"LOG"};var y={startListeners:async({db:e,pubsub:t,queueSettings:s})=>new Promise((e,t)=>{const n=new a(s.redis);n.subscribe("livechat.send","livechat.stop",(s,n)=>{s?t(new Error(`Redis subscribe failed: ${s}`)):(S(`Livechat Redis connected to ${n} channels.`),e())}),n.on("message",async(e,t)=>{const{conversationId:s,convoStep:n}=JSON.parse(t);if(!E[s])return;const a=E[s];"livechat.send"===e?(S(`liveChatSendToBot(${s}) sending convoStep ${i.inspect(n)}`),v(a,f.USER_SAYS,n)):"livechat.stop"===e&&I(s)})}),startBot:async({caps:s},{pubsub:n,queueSettings:o})=>{const c=new a(o.redis),p=t(),l=new r(async(e,t)=>{try{const t=await h({conversationId:p},{queueSettings:o}),s=t.length,a=JSON.stringify(Object.assign(e,{convoStepIndex:s}));n.publish(p,{liveChatConvoStepAdded:{convoStep:a}}),t.push(a),_(p,t,c),T({conversationId:p,queueSettings:o,pubsub:n})}catch(e){S(`listenerQueue err: ${e}`)}t()}),O=u(e.resolve(__dirname,process.env.BOTIUMBOX_LIVECHAT_WORKER_FILE||"livechatWorker.js"),[JSON.stringify({caps:s,conversationId:p})],{execArgv:["--inspect=0"]});return O.on("message",({type:e,message:t})=>{switch(S(`Received IPC message ${e} from worker. conversationId: ${p}, message: ${i.inspect(t)}`),e){case f.USER_SAYS_FAILED:S(`liveChatSendToBot UserSays failed: ${t}`),n.publish(p,{liveChatConvoStepAdded:{err:`${t}`}});break;case f.LOG:d(t);break;case f.STOP_CONVERSATION_FINISHED:delete O[t.conversationId];break;case f.MESSAGE_SENTTOBOT:case f.MESSAGE_RECEIVEDFROMBOT:l.push(t);break;default:S(`Unknown message type: ${e}`)}}),E[p]=O,_(p,[],c),T({conversationId:p,queueSettings:o,pubsub:n}),p},sendToBot:async({conversationId:e,convoStep:t},{queueSettings:s})=>{new a(s.redis).publish("livechat.send",JSON.stringify({conversationId:e,convoStep:t}))},stopBot:async({conversationId:e},{queueSettings:t})=>{new a(t.redis).publish("livechat.stop",JSON.stringify({conversationId:e}))},getConversation:h,getConversationScript:async({caps:e,conversationId:t,testCaseName:s},{queueSettings:a})=>{const r=await h({conversationId:t},{queueSettings:a});if(!n.isArray(r))throw new Error("Conversation not available (anymore).");const o=new p(e).BuildCompiler(),i={header:{name:s},conversation:r.map(e=>(e=>(e.asserters||(e.asserters=[]),e.nlp&&(e.nlp.intent&&e.asserters.push({name:"INTENT",args:[e.nlp.intent.name]}),e.nlp.entities&&e.asserters.push({name:"ENTITIES",args:e.nlp.entities.map(e=>e.name)})),e))(JSON.parse(e)))},c=o.Decompile([i],"SCRIPTING_FORMAT_TXT");return S(`Decompiled script: ${c}`),c},IPC_MESSAGE_TYPE:f};const m=c.BotDriver,{IPC_MESSAGE_TYPE:b}=y;let g,w;const A=e=>{C(b.LOG,e)};process.on("message",({type:e,message:t})=>{switch(A(`Received IPC message ${e} from worker. Message: ${i.inspect(t)}`),e){case b.USER_SAYS:N(t);break;case b.STOP_CONVERSATION:R();break;default:A(`Unknown message type: ${e}`),process.exit(1)}});const C=(e,t)=>{process.send({type:e,message:t})},N=async e=>{try{await g.UserSays(e)}catch(e){C(b.USER_SAYS_FAILED,e)}},R=async()=>{try{await g.Stop()}catch(e){A(`stopConversation(${w}) Stop failed: ${e}`)}try{await g.Clean()}catch(e){A(`stopConversation(${w}) Clean failed: ${e}`)}A(`stopConversation(${w}) container stopped.`),C(b.STOP_CONVERSATION_FINISHED,{conversationId:w})};(async e=>{w=e.conversationId;const t=new m(e.caps);t.on("MESSAGE_SENTTOBOT",(e,t)=>C(b.MESSAGE_SENTTOBOT,t)),t.on("MESSAGE_RECEIVEDFROMBOT",(e,t)=>C(b.MESSAGE_RECEIVEDFROMBOT,t)),g=await t.Build(),A(`liveChatStartBot(${w}) container built, now starting`),await g.Start(),A(`liveChatStartBot(${w}) container started.`)})(JSON.parse(process.argv[2])).catch(e=>{A(`Failed to start worker: ${e}`),process.exit(1)});return{}});
