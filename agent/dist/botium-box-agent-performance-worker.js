!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("util"),require("path"),require("slugify"),require("nodegit"),require("botium-core/src/scripting/Constants"),require("debug"),require("botium-core/src/Capabilities"),require("p-queue"),require("delay"),require("botium-core"),require("botium-core/src/Fluent")):"function"==typeof define&&define.amd?define(["util","path","slugify","nodegit","botium-core/src/scripting/Constants","debug","botium-core/src/Capabilities","p-queue","delay","botium-core","botium-core/src/Fluent"],t):e.main=t(e.util,e.path,e.slugify,e.nodegit,e.Constants,e.debug,e.Capabilities,e.pQueue,e.delay,e.botiumCore,e.Fluent)}(this,function(e,t,o,r,s,n,a,i,c,u,l){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,t=t&&t.hasOwnProperty("default")?t.default:t,o=o&&o.hasOwnProperty("default")?o.default:o,r=r&&r.hasOwnProperty("default")?r.default:r,s=s&&s.hasOwnProperty("default")?s.default:s,n=n&&n.hasOwnProperty("default")?n.default:n,a=a&&a.hasOwnProperty("default")?a.default:a,i=i&&i.hasOwnProperty("default")?i.default:i,c=c&&c.hasOwnProperty("default")?c.default:c,u=u&&u.hasOwnProperty("default")?u.default:u,l=l&&l.hasOwnProperty("default")?l.default:l;const p=n("botium-retrieve-all-test-cases");var T={prepareConvos:(e,t,o)=>{const r=e.testSets.filter(e=>e.expandConvos).length>0,s=e.testSets.filter(e=>e.expandUtterancesToConvos).length>0,n=e.testSets.filter(e=>e.expandScriptingMemory).length>0;return s&&(o("expanding utterances to convos ..."),t.compiler.ExpandUtterancesToConvos()),n&&(o("expanding scripting memories to convos ..."),t.compiler.ExpandScriptingMemoryToConvos()),(r||s||n)&&(o("expanding convos ..."),t.compiler.ExpandConvos()),o(`found ${t.compiler.convos.length} convos ...`),t.compiler.convos},merge:(e,t,o)=>{const r={};e.botium&&e.botium.Capabilities&&Object.assign(r,e.botium.Capabilities),t.botium&&t.botium.Capabilities&&Object.assign(r,t.botium.Capabilities);const s={};e.botium&&e.botium.Sources&&Object.assign(s,e.botium.Sources),t.botium&&t.botium.Sources&&Object.assign(s,t.botium.Sources);const n=o?process.env:{};return e.botium&&e.botium.Envs&&Object.assign(n,e.botium.Envs),t.botium&&t.botium.Envs&&Object.assign(n,t.botium.Envs),{caps:r,sources:s,envs:n}},MESSAGE_TYPE:{CANCEL:"CANCEL",STOP:"STOP",CREATE_JOB:"CREATE_JOB",CREATE_JOB_COMPLETE:"CREATE_JOB_COMPLETE",CREATE_JOB_FAILED:"CREATE_JOB_FAILED",RESULT:"RESULT",LOG:"LOG"}};const d=u.BotDriver,{prepareConvos:m,merge:C,MESSAGE_TYPE:f}=T,S=e=>{h(f.LOG,e)};let I=!1,E=0,g={};process.on("message",({type:e,requestId:t})=>{switch(e){case f.CANCEL:I=!0;break;case f.CREATE_JOB_COMPLETE:g[t].resolve(),delete g[t];break;case f.CREATE_JOB_FAILED:g[t].reject(),delete g[t];break;default:S(`Unknown message type: ${e}`),process.exit(1)}});const h=(e,t,o)=>{process.send({type:e,message:t,requestId:o})},P=({data:e,testState:t,tools:o})=>{const r=new Date,{botDriver:s}=o,n=new l(s);n.compiler=o.fluent.compiler,n.currentChannel=o.fluent.currentChannel;const a=n.compiler.convos[t.convoIndex];S(`Performance test executing Convo "${a.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`);let i=null,c=null;return new Promise((o,s)=>{n.Call(()=>{if(I)throw new Error("Test Session cancelled")}),n.Start().Call(()=>new Promise(o=>{if(!I)return a.Run(n.container).then(e=>{i=e,o()}).catch(e=>{S(`Running Convo "${a.header.name}" failed: ${e}.`),i=e.transcript,c=e,o()});S(`Performance test Session cancelled, skipping Convo "${a.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`),o()})).Stop(),n.Call(()=>{if(I)throw new Error("Test Session cancelled")}),n.Call(()=>new Promise((o,s)=>{if(I)return o();const n=i.steps.reduce((e,t)=>e+(t.botEnd.getTime()-t.botBegin.getTime()),0),u={performanceTestSessionId:e.performanceTestSessionId,performanceTestSessionName:e.performanceTestSessionName,performanceTestSessionJobId:e.performanceTestSessionJobId,convo:a.header.name||null,convoIndex:t.convoIndex,success:null===c,err:c?c.message?c.message:JSON.stringify(c):null,tick:t.tickIndex,repeat:t.repeat,runtime:n,queueBegin:t.queueBegin,testBegin:r,testEnd:new Date};S(`performanceprocess.progress: ${JSON.stringify(u)}.`),((e,t)=>{const o={requestId:++E};g[E]=o;const r=new Promise((r,s)=>{h(f.CREATE_JOB,{type:e,data:t},o.requestId),o.resolve=r,o.reject=s});return o.promise=r,r})("performanceprocess.progress",u).then(e=>{o(e)}).catch(e=>{s(e)})})),n.Clean(),n.Exec().then(()=>{S(`Performance test executed Convo "${a.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`),o()}).catch(e=>{S(`Performance Test Session Run failed (${e}), doing additional BotDriver Clean.`),n.Clean().Exec().catch(e=>S(e)).then(()=>{s(e)})})})},R=({agentConfig:t,jobId:o,data:r})=>{S(`Started processing, JobId #${o} Data: ${e.inspect(r)}.`);const{caps:n,sources:u,envs:l}=C(t,r,!1),T=new d(n,u,l),f=T.BuildFluent();return f.compiler=T.BuildCompiler(),T._validate().then(()=>new Promise((t,o)=>{Promise.all(r.testSets.map(t=>((t,o,r,n)=>{t.convos&&t.convos.forEach(r=>{let n=[];try{r.format===s.SCRIPTING_FORMAT_TXT&&(n=o.Compile(r.content,s.SCRIPTING_FORMAT_TXT,s.SCRIPTING_TYPE_CONVO)),n&&n.forEach(e=>{e.sourceTag=r.sourceTag})}catch(o){throw p(o),new Error(`${t.name}: Convo Script compilation failed: ${e.inspect(o)}`)}}),t.pconvos&&t.pconvos.forEach(r=>{let n=[];try{r.format===s.SCRIPTING_FORMAT_TXT&&(n=o.Compile(r.content,s.SCRIPTING_FORMAT_TXT,s.SCRIPTING_TYPE_PCONVO)),n&&n.forEach(e=>{e.sourceTag=r.sourceTag})}catch(o){throw p(o),new Error(`${t.name}: Partial Convo Script compilation failed: ${e.inspect(o)}`)}}),t.utterances&&t.utterances.forEach(r=>{let n=[];try{r.format===s.SCRIPTING_FORMAT_TXT&&(n=o.Compile(r.content,s.SCRIPTING_FORMAT_TXT,s.SCRIPTING_TYPE_UTTERANCES)),n&&n.forEach(e=>{e.sourceTag=r.sourceTag})}catch(o){throw p(o),new Error(`${t.name}: Utterance script compilation failed: ${e.inspect(o)}`)}}),t.scriptingMemories&&t.scriptingMemories.forEach(r=>{let n=[];try{r.format===s.SCRIPTING_FORMAT_TXT&&(n=o.Compile(r.content,s.SCRIPTING_FORMAT_TXT,s.SCRIPTING_TYPE_SCRIPTING_MEMORY)),n&&n.forEach(e=>{e.sourceTag=r.sourceTag})}catch(o){throw p(o),new Error(`${t.name}: Scripting Memory script compilation failed: ${e.inspect(o)}`)}}),t.folders&&t.folders.forEach(r=>{try{const{convos:s,pconvos:n,utterances:a}=o.ReadScriptsFromDirectory(r.path,r.globFilter);s&&s.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,r.sourceTag)}),n&&n.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,r.sourceTag)}),a&&a.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,r.sourceTag)})}catch(o){throw p(o),new Error(`${t.name}: Folder ${r} script compilation failed: ${e.inspect(o)}`)}});let i=Promise.resolve();t.excels&&t.excels.length>0&&(i=Promise.all(t.excels.map(({id:e,filename:t,filecontent:r,hasConvos:n,hasPartialConvos:i,hasUtterances:c,worksheetsConvos:u,worksheetsPartialConvos:l,worksheetsUtterances:p,startRow:T,startCol:d,sourceTag:m})=>new Promise(e=>{const t=Buffer.from(r,"base64");let C=[],f=[],S=[];n&&(u&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES]=u),isNaN(T)||(o.caps[a.SCRIPTING_XLSX_STARTROW]=T),isNaN(d)||(o.caps[a.SCRIPTING_XLSX_STARTCOL]=d),C=o.Compile(t,s.SCRIPTING_FORMAT_XSLX,s.SCRIPTING_TYPE_CONVO)),i&&(l&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]=l),isNaN(T)||(o.caps[a.SCRIPTING_XLSX_STARTROW]=T),isNaN(d)||(o.caps[a.SCRIPTING_XLSX_STARTCOL]=d),f=o.Compile(t,s.SCRIPTING_FORMAT_XSLX,s.SCRIPTING_TYPE_PCONVO)),c&&(p&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]=p),isNaN(T)||(o.caps[a.SCRIPTING_XLSX_STARTROW]=T),isNaN(d)||(o.caps[a.SCRIPTING_XLSX_STARTCOL]=d),S=o.Compile(t,s.SCRIPTING_FORMAT_XSLX,s.SCRIPTING_TYPE_UTTERANCES)),C&&C.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),f&&f.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),S&&S.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),e()}))));let c=Promise.resolve();return Promise.all([c,i])})(t,f.compiler,T.tempDirectory,T.sources))).then(()=>m(r,f,S)).then(e=>{t(e.reduce((e,t)=>e.concat(t),[]))}).catch(o)})).then(()=>{f.compiler.ExpandConvos();const t=new i({concurrency:r.parallelConvoCount||20});return r.tickCount=Math.floor(r.tickMaxTime/r.tickTime+1),(async({jobId:t,data:o,tools:r})=>{S(`mainQueueFeeder JobId #${t}`);const s=({jobId:t,data:o,tickIndex:r,tools:s})=>{const{fluent:n,queue:a}=s,i=o.tickRepeatInitial+o.tickRepeatPerTick*r;S(`tickQueueFeederAsync JobId #${t} tickIndex ${r} repeats ${i}.`);for(let e=0;e<i;e++)for(let t=0;t<n.compiler.convos.length;t++){const n=new Date;a.add(()=>P({data:o,testState:{convoIndex:t,tickIndex:r,maxRepeat:i,repeat:e,queueBegin:n},tools:s}))}const{performanceTestSessionId:c,performanceTestSessionJobId:u,performanceTestSessionName:l}=o,p={performanceTestSessionId:c,performanceTestSessionName:l,performanceTestSessionJobId:u,addedInTick:i,tickIndex:r,executing:s.queue.pending,waiting:s.queue.size};S(`Tick ${e.inspect(p)}`)};for(let e=0;e<o.tickCount;e++)await s({jobId:t,data:o,tickIndex:e,tools:r}),await c(o.tickTime);await(e=>new Promise((t,o)=>{e.onIdle().then(()=>{t()})}))(r.queue),S(`mainQueueFeeder JobId #${t} finished`)})({jobId:o,data:r,tools:{botDriver:T,fluent:f,queue:t}})})};let b;try{b=JSON.parse(process.argv[2])}catch(e){S("Init: Failed to parse args!"),process.exit(1)}b&&R(b).then(e=>(h(f.RESULT,e),S("Exiting, worker finished"),Promise.all(Object.values(g).map(e=>e.promise)).then(()=>process.exit(0)))).catch(t=>(S(`Exiting, error occured: ${e.inspect(t)}`),Promise.all(Object.values(g).map(e=>e.promise)).then(()=>process.exit(1))));return{}});
