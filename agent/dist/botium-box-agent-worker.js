!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("util"),require("path"),require("slugify"),require("nodegit"),require("botium-core/src/scripting/Constants"),require("debug"),require("botium-core/src/Capabilities"),require("lodash"),require("intercept-stdout"),require("botium-core")):"function"==typeof define&&define.amd?define(["util","path","slugify","nodegit","botium-core/src/scripting/Constants","debug","botium-core/src/Capabilities","lodash","intercept-stdout","botium-core"],t):e.main=t(e.util,e.path,e.slugify,e.nodegit,e.Constants,e.debug,e.Capabilities,e.lodash,e.interceptStdout,e.botiumCore)}(this,function(e,t,o,s,r,n,a,c,i,l){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,t=t&&t.hasOwnProperty("default")?t.default:t,o=o&&o.hasOwnProperty("default")?o.default:o,s=s&&s.hasOwnProperty("default")?s.default:s,r=r&&r.hasOwnProperty("default")?r.default:r,n=n&&n.hasOwnProperty("default")?n.default:n,a=a&&a.hasOwnProperty("default")?a.default:a,c=c&&c.hasOwnProperty("default")?c.default:c,i=i&&i.hasOwnProperty("default")?i.default:i,l=l&&l.hasOwnProperty("default")?l.default:l;const u=n("botium-retrieve-all-test-cases");var T={prepareConvos:(e,t,o)=>{const s=e.testSets.filter(e=>e.expandConvos).length>0,r=e.testSets.filter(e=>e.expandUtterancesToConvos).length>0,n=e.testSets.filter(e=>e.expandScriptingMemory).length>0;return r&&(o("expanding utterances to convos ..."),t.compiler.ExpandUtterancesToConvos()),n&&(o("expanding scripting memories to convos ..."),t.compiler.ExpandScriptingMemoryToConvos()),(s||r||n)&&(o("expanding convos ..."),t.compiler.ExpandConvos()),o(`found ${t.compiler.convos.length} convos ...`),t.compiler.convos},merge:(e,t,o)=>{const s={};e.botium&&e.botium.Capabilities&&Object.assign(s,e.botium.Capabilities),t.botium&&t.botium.Capabilities&&Object.assign(s,t.botium.Capabilities);const r={};e.botium&&e.botium.Sources&&Object.assign(r,e.botium.Sources),t.botium&&t.botium.Sources&&Object.assign(r,t.botium.Sources);const n=o?c.cloneDeep(process.env):{};return e.botium&&e.botium.Envs&&Object.assign(n,e.botium.Envs),t.botium&&t.botium.Envs&&Object.assign(n,t.botium.Envs),{caps:s,sources:r,envs:n}},MESSAGE_TYPE:{CANCEL:"CANCEL",STOP:"STOP",CREATE_JOB:"CREATE_JOB",CREATE_JOB_COMPLETE:"CREATE_JOB_COMPLETE",CREATE_JOB_FAILED:"CREATE_JOB_FAILED",RESULT:"RESULT",LOG:"LOG"}};const p=l.BotDriver,{prepareConvos:m,merge:E,MESSAGE_TYPE:h}=T,C=e=>{b(h.LOG,e)};let S=!1,d=!1,g=0,f={};process.on("message",({type:e,requestId:t})=>{switch(e){case h.CANCEL:S=!0;break;case h.STOP:d=!0;break;case h.CREATE_JOB_COMPLETE:f[t].resolve(),delete f[t];break;case h.CREATE_JOB_FAILED:f[t].reject(),delete f[t];break;default:C(`Unknown message type: ${e}`),process.exit(1)}});const O=(e,t)=>{const o={requestId:++g};f[g]=o;const s=new Promise((s,r)=>{b(h.CREATE_JOB,{type:e,data:t},o.requestId),o.resolve=s,o.reject=r});return o.promise=s,s},b=(e,t,o)=>{process.send({type:e,message:t,requestId:o})},_=({agentConfig:t,jobId:o,data:s})=>{const{testSessionId:n,testSessionName:c,testSessionJobId:l}=s,T={unhook:null},h=()=>{T.unhook&&(T.unhook(),T.unhook=null)};return new Promise((h,g)=>{T.unhook=i(e=>{if(t.debug){const t=e.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,"");O("process.log",{testSessionId:n,testSessionName:c,testSessionJobId:l,log:t})}return e}),C(`Started processing, JobId #${o}.`);const{caps:f,sources:b,envs:_}=E(t,s,!1),I=new p(f,b,_),R=I.BuildFluent();R.compiler=I.BuildCompiler(),I._validate().then(()=>new Promise((t,o)=>{Promise.all(s.testSets.map(t=>((t,o,s)=>{const{excelHasConvos:n,excelHasPartialConvos:c,excelHasUtterances:i,excelWorksheetsConvos:l,excelWorksheetsPartialConvos:T,excelWorksheetsUtterances:p,excelStartRow:m,excelStartCol:E}=t;n&&l&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES]=l),c&&T&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]=T),i&&p&&(o.caps[a.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]=p),isNaN(m)||(o.caps[a.SCRIPTING_XLSX_STARTROW]=m),isNaN(E)||(o.caps[a.SCRIPTING_XLSX_STARTCOL]=E),t.convos&&t.convos.forEach(s=>{let n=[];try{s.format===r.SCRIPTING_FORMAT_TXT&&(n=o.Compile(s.content,r.SCRIPTING_FORMAT_TXT,r.SCRIPTING_TYPE_CONVO)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(o){throw u(o),new Error(`${t.name}: Convo Script compilation failed: ${e.inspect(o)}`)}}),t.pconvos&&t.pconvos.forEach(s=>{let n=[];try{s.format===r.SCRIPTING_FORMAT_TXT&&(n=o.Compile(s.content,r.SCRIPTING_FORMAT_TXT,r.SCRIPTING_TYPE_PCONVO)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(o){throw u(o),new Error(`${t.name}: Partial Convo Script compilation failed: ${e.inspect(o)}`)}}),t.utterances&&t.utterances.forEach(s=>{let n=[];try{s.format===r.SCRIPTING_FORMAT_TXT&&(n=o.Compile(s.content,r.SCRIPTING_FORMAT_TXT,r.SCRIPTING_TYPE_UTTERANCES)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(o){throw u(o),new Error(`${t.name}: Utterance script compilation failed: ${e.inspect(o)}`)}}),t.scriptingMemories&&t.scriptingMemories.forEach(s=>{let n=[];try{s.format===r.SCRIPTING_FORMAT_TXT&&(n=o.Compile(s.content,r.SCRIPTING_FORMAT_TXT,r.SCRIPTING_TYPE_SCRIPTING_MEMORY)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(o){throw u(o),new Error(`${t.name}: Scripting Memory script compilation failed: ${e.inspect(o)}`)}}),t.folders&&t.folders.forEach(s=>{try{const{convos:r,pconvos:n,utterances:a}=o.ReadScriptsFromDirectory(s.path,s.globFilter);r&&r.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)}),n&&n.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)}),a&&a.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)})}catch(o){throw u(o),new Error(`${t.name}: Folder ${s} script compilation failed: ${e.inspect(o)}`)}});let h=Promise.resolve();t.excels&&t.excels.length>0&&(h=Promise.all(t.excels.map(({id:e,filename:t,filecontent:s,sourceTag:a})=>new Promise(e=>{const t=Buffer.from(s,"base64");let l=[],u=[],T=[];n&&(l=o.Compile(t,r.SCRIPTING_FORMAT_XSLX,r.SCRIPTING_TYPE_CONVO)),c&&(u=o.Compile(t,r.SCRIPTING_FORMAT_XSLX,r.SCRIPTING_TYPE_PCONVO)),i&&(T=o.Compile(t,r.SCRIPTING_FORMAT_XSLX,r.SCRIPTING_TYPE_UTTERANCES)),l&&l.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,a)}),u&&u.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,a)}),T&&T.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,a)}),e()}))));let C=Promise.resolve();return Promise.all([C,h])})(t,R.compiler,I.tempDirectory))).then(()=>m(s,R,C)).then(e=>{t(e.reduce((e,t)=>e.concat(t),[]))}).catch(o)})).then(()=>{const e=s.batchNum||1,t=s.batchCount||1,o=Math.ceil(R.compiler.convos.length/t),r=o*(e-1),a=Math.min(r+o,R.compiler.convos.length)-1,i=a-r+1,u={batchNum:e,totalCount:0,failedCount:0,successCount:0};C(`batchNum: ${e} batchCount: ${t} convosPerBatch: ${o} batchStart: ${r} batchEnd: ${a} batchLength: ${i}`);for(let t=r;t<=a;t++){const T=t,p=R.compiler.convos[T];let m=null;const E=[],h=(e,t)=>{t.attachments&&E.push(...t.attachments)},g=(e,t)=>{t.attachments&&E.push(...t.attachments)},f=(e,t)=>{E.push(t)},b=(e,t)=>{t&&(p.sourceTag=Object.assign({},p.sourceTag,t))},_=()=>{I.eventEmitter.removeListener("MESSAGE_SENTTOBOT",h),I.eventEmitter.removeListener("MESSAGE_RECEIVEDFROMBOT",g),I.eventEmitter.removeListener("MESSAGE_ATTACHMENT",f),I.eventEmitter.removeListener("CONTAINER_STARTED",b)},P=()=>{I.on("MESSAGE_SENTTOBOT",h),I.on("MESSAGE_RECEIVEDFROMBOT",g),I.on("MESSAGE_ATTACHMENT",f),I.on("CONTAINER_STARTED",b)};let v=null;R.Call(()=>{if(S)throw new Error("Test Session cancelled")}),R.Call(P).Start(),R.Call(()=>new Promise(e=>{if(S)C(`Test Session cancelled, skipping Convo "${p.header.name}", Index ${T}, ${T-r} from ${o}`),e();else if(d)C(`Test Session stopped, skipping Convo "${p.header.name}", Index ${T}, ${T-r} from ${o}`),e();else{C(`Running Convo "${p.header.name}", Index ${T}, ${T-r+1} from ${i}`);try{return p.Run(R.container).then(t=>{C(`Running Convo "${p.header.name}" completed successfully.`),m=t,e()}).catch(t=>{C(`Running Convo "${p.header.name}" failed: ${t}.`),m=t.transcript,v=t,e()})}catch(t){v=t,e()}}})),R.Stop().Call(_),R.Call(()=>{if(S)throw new Error("Test Session cancelled")}),R.Call(()=>new Promise((t,h)=>S?t():d?t():(m&&(m.err=m.err?m.err.message?m.err.message:JSON.stringify(m.err):null,m.steps&&m.steps.forEach(e=>{e.err=e.err?e.err.message?e.err.message:JSON.stringify(e.err):null})),u.totalCount++,v?u.failedCount++:u.successCount++,null!==v&&s.bail&&(d=!0),void O("process.progress",{testSessionId:n,testSessionName:c,testSessionJobId:l,currentBatchIndex:T,batchNum:e,batchStart:r,batchEnd:a,batchLength:i,convosPerBatch:o,progress:Math.round((T-r+1)/i*100),testcase:p.header.name,source:p.toString(),sourceTag:p.sourceTag,transcript:m,attachments:E,success:null===v,err:v?v.message?v.message:JSON.stringify(v):null,stopTestSession:null!==v&&s.bail}).then(e=>{t(e)}).catch(e=>{h(e)}))))}R.Clean(),R.Exec().then(()=>h(u)).catch(e=>{R.container?(C(`Test Session Run failed (${e}), doing additional BotDriver Clean.`),R.container.Clean().catch(e=>C(e)).then(()=>{e.result=u,g(e)})):(C(`Test Session Run failed (${e}).`),g(e))})}).catch(g)}).then(e=>(h(),e)).catch(e=>{throw h(),e})};let I;try{I=JSON.parse(process.argv[2])}catch(e){C("Init: Failed to parse args!"),process.exit(1)}I&&_(I).then(e=>(b(h.RESULT,e),Promise.all(Object.values(f).map(e=>e.promise)).then(()=>process.exit(0)))).catch(()=>Promise.all(Object.values(f).map(e=>e.promise)).then(()=>process.exit(1)));return{}});
