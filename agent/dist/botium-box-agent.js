!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("util"),require("path"),require("slugify"),require("nodegit"),require("botium-core/src/scripting/Constants"),require("botium-core/src/Capabilities"),require("intercept-stdout"),require("botium-core"),require("debug"),require("dotenv-flow"),require("os"),require("kue")):"function"==typeof define&&define.amd?define(["util","path","slugify","nodegit","botium-core/src/scripting/Constants","botium-core/src/Capabilities","intercept-stdout","botium-core","debug","dotenv-flow","os","kue"],t):e.main=t(e.util,e.path,e.slugify,e.nodegit,e.Constants,e.Capabilities,e.interceptStdout,e.botiumCore,e.debug,e.dotenvFlow,e.os,e.kue)}(this,function(e,t,s,o,n,r,i,a,c,l,u,T){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,t=t&&t.hasOwnProperty("default")?t.default:t,s=s&&s.hasOwnProperty("default")?s.default:s,o=o&&o.hasOwnProperty("default")?o.default:o,n=n&&n.hasOwnProperty("default")?n.default:n,r=r&&r.hasOwnProperty("default")?r.default:r,i=i&&i.hasOwnProperty("default")?i.default:i,a=a&&a.hasOwnProperty("default")?a.default:a,c=c&&c.hasOwnProperty("default")?c.default:c,l=l&&l.hasOwnProperty("default")?l.default:l,u=u&&u.hasOwnProperty("default")?u.default:u,T=T&&T.hasOwnProperty("default")?T.default:T;const d={buildTarget:"COMMUNITY EDITION",buildBranch:"release/1.5.1",buildRevision:"5017f71cbfc5b97533e845df38cda4200f48ae34",buildDate:"2019-05-19T22:23:29+02:00"};var p=()=>{console.log("BOTIUM BOX - AGENT"),console.log(`BUILD_TARGET: ${d.buildTarget}`),console.log(`BUILD_BRANCH: ${d.buildBranch}`),console.log(`BUILD_REVISION: ${d.buildRevision}`),console.log(`BUILD_TIMESTAMP: ${d.buildDate}`)};const S=c("botium-retrieve-all-test-cases");const g=a.BotDriver,E=c("botium-box-worker-runtestcases"),m={},f={},h=e=>{f[e]&&(f[e].forEach(e=>e()),delete f[e],E(`Worker for ${e} stopped.`))};var I=(t,{id:s,data:o},a)=>{const{testSessionId:c,testSessionName:l,testSessionJobId:u}=o;let T=!1,d=!1;((e,t,s)=>{m[e]||(m[e]=[]),f[e]||(f[e]=[]),m[e].push(t),f[e].push(s)})(c,()=>{T=!0},()=>{d=!0});const p={unhook:null},I=()=>{p.unhook&&(p.unhook(),p.unhook=null)};return new Promise((m,f)=>{p.unhook=i(e=>{if(t.debug){const t=e.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,"");a("process.log",{testSessionId:c,testSessionName:l,testSessionJobId:u,log:t})}return e}),E(`Started processing, JobId #${s}.`);const I={};t.botium&&t.botium.Capabilities&&Object.assign(I,t.botium.Capabilities),o.botium&&o.botium.Capabilities&&Object.assign(I,o.botium.Capabilities);const O={};t.botium&&t.botium.Sources&&Object.assign(O,t.botium.Sources),o.botium&&o.botium.Sources&&Object.assign(O,o.botium.Sources);const _={};t.botium&&t.botium.Envs&&Object.assign(_,t.botium.Envs),o.botium&&o.botium.Envs&&Object.assign(_,o.botium.Envs);const b=new g(I,O,_),R=b.BuildFluent();R.compiler=b.BuildCompiler(),b._validate().then(()=>new Promise((t,s)=>{Promise.all(o.testSets.map(t=>((t,s,o,i)=>{t.convos&&t.convos.forEach(o=>{let r=[];try{o.format===n.SCRIPTING_FORMAT_TXT&&(r=s.Compile(o.content,n.SCRIPTING_FORMAT_TXT,n.SCRIPTING_TYPE_CONVO)),r&&r.forEach(e=>{e.sourceTag=o.sourceTag})}catch(s){throw S(s),new Error(`${t.name}: Convo Script compilation failed: ${e.inspect(s)}`)}}),t.pconvos&&t.pconvos.forEach(o=>{let r=[];try{o.format===n.SCRIPTING_FORMAT_TXT&&(r=s.Compile(o.content,n.SCRIPTING_FORMAT_TXT,n.SCRIPTING_TYPE_PCONVO)),r&&r.forEach(e=>{e.sourceTag=o.sourceTag})}catch(s){throw S(s),new Error(`${t.name}: Partial Convo Script compilation failed: ${e.inspect(s)}`)}}),t.utterances&&t.utterances.forEach(o=>{let r=[];try{o.format===n.SCRIPTING_FORMAT_TXT&&(r=s.Compile(o.content,n.SCRIPTING_FORMAT_TXT,n.SCRIPTING_TYPE_UTTERANCES)),r&&r.forEach(e=>{e.sourceTag=o.sourceTag})}catch(s){throw S(s),new Error(`${t.name}: Utterance script compilation failed: ${e.inspect(s)}`)}}),t.scriptingMemories&&t.scriptingMemories.forEach(o=>{let r=[];try{o.format===n.SCRIPTING_FORMAT_TXT&&(r=s.Compile(o.content,n.SCRIPTING_FORMAT_TXT,n.SCRIPTING_TYPE_SCRIPTING_MEMORY)),r&&r.forEach(e=>{e.sourceTag=o.sourceTag})}catch(s){throw S(s),new Error(`${t.name}: Scripting Memory script compilation failed: ${e.inspect(s)}`)}}),t.folders&&t.folders.forEach(o=>{try{const{convos:n,pconvos:r,utterances:i}=s.ReadScriptsFromDirectory(o.path,o.globFilter);n&&n.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,o.sourceTag)}),r&&r.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,o.sourceTag)}),i&&i.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,o.sourceTag)})}catch(s){throw S(s),new Error(`${t.name}: Folder ${o} script compilation failed: ${e.inspect(s)}`)}});let a=Promise.resolve();t.excels&&t.excels.length>0&&(a=Promise.all(t.excels.map(({id:e,filename:t,filecontent:o,hasConvos:i,hasPartialConvos:a,hasUtterances:c,worksheetsConvos:l,worksheetsPartialConvos:u,worksheetsUtterances:T,startRow:d,startCol:p,sourceTag:S})=>new Promise(e=>{const t=Buffer.from(o,"base64");let g=[],E=[],m=[];i&&(l&&(s.caps[r.SCRIPTING_XLSX_SHEETNAMES]=l),isNaN(d)||(s.caps[r.SCRIPTING_XLSX_STARTROW]=d),isNaN(p)||(s.caps[r.SCRIPTING_XLSX_STARTCOL]=p),g=s.Compile(t,n.SCRIPTING_FORMAT_XSLX,n.SCRIPTING_TYPE_CONVO)),a&&(u&&(s.caps[r.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]=u),isNaN(d)||(s.caps[r.SCRIPTING_XLSX_STARTROW]=d),isNaN(p)||(s.caps[r.SCRIPTING_XLSX_STARTCOL]=p),E=s.Compile(t,n.SCRIPTING_FORMAT_XSLX,n.SCRIPTING_TYPE_PCONVO)),c&&(T&&(s.caps[r.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]=T),isNaN(d)||(s.caps[r.SCRIPTING_XLSX_STARTROW]=d),isNaN(p)||(s.caps[r.SCRIPTING_XLSX_STARTCOL]=p),m=s.Compile(t,n.SCRIPTING_FORMAT_XSLX,n.SCRIPTING_TYPE_UTTERANCES)),g&&g.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,S)}),E&&E.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,S)}),m&&m.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,S)}),e()}))));let c=Promise.resolve();return Promise.all([c,a])})(t,R.compiler,b.tempDirectory,b.sources))).then(()=>{const e=o.testSets.filter(e=>e.expandConvos).length>0,t=o.testSets.filter(e=>e.expandUtterancesToConvos).length>0,s=o.testSets.filter(e=>e.expandScriptingMemory).length>0;return t&&(E("expanding utterances to convos ..."),R.compiler.ExpandUtterancesToConvos()),s&&(E("expanding scripting memories to convos ..."),R.compiler.ExpandScriptingMemoryToConvos()),(e||t||s)&&(E("expanding convos ..."),R.compiler.ExpandConvos()),E(`found ${R.compiler.convos.length} convos ...`),R.compiler.convos}).then(e=>{t(e.reduce((e,t)=>e.concat(t),[]))}).catch(s)})).then(()=>{const e=o.batchNum||1,t=o.batchCount||1,s=Math.ceil(R.compiler.convos.length/t),n=s*(e-1),r=Math.min(n+s,R.compiler.convos.length)-1,i=r-n+1,p={batchNum:e,totalCount:0,failedCount:0,successCount:0};E(`batchNum: ${e} batchCount: ${t} convosPerBatch: ${s} batchStart: ${n} batchEnd: ${r} batchLength: ${i}`);for(let t=n;t<=r;t++){const S=t,g=R.compiler.convos[S];let m=null;const f=[],I=(e,t)=>{t.attachments&&f.push(...t.attachments)},O=(e,t)=>{t.attachments&&f.push(...t.attachments)},_=(e,t)=>{f.push(t)},C=(e,t)=>{t&&(g.sourceTag=Object.assign({},g.sourceTag,t))},N=()=>{b.eventEmitter.removeListener("MESSAGE_SENTTOBOT",I),b.eventEmitter.removeListener("MESSAGE_RECEIVEDFROMBOT",O),b.eventEmitter.removeListener("MESSAGE_ATTACHMENT",_),b.eventEmitter.removeListener("CONTAINER_STARTED",C)},$=()=>{b.on("MESSAGE_SENTTOBOT",I),b.on("MESSAGE_RECEIVEDFROMBOT",O),b.on("MESSAGE_ATTACHMENT",_),b.on("CONTAINER_STARTED",C)};let v=null;R.Call(()=>{if(T)throw new Error("Test Session cancelled")}),R.Call($).Start(),R.Call(()=>new Promise(e=>{if(T)E(`Test Session cancelled, skipping Convo "${g.header.name}", Index ${S}, ${S-n} from ${s}`),e();else if(d)E(`Test Session stopped, skipping Convo "${g.header.name}", Index ${S}, ${S-n} from ${s}`),e();else{E(`Running Convo "${g.header.name}", Index ${S}, ${S-n+1} from ${i}`);try{return g.Run(R.container).then(t=>{E(`Running Convo "${g.header.name}" completed successfully.`),m=t,e()}).catch(t=>{E(`Running Convo "${g.header.name}" failed: ${t}.`),m=t.transcript,v=t,e()})}catch(t){v=t,e()}}})),R.Stop().Call(N),R.Call(()=>{if(T)throw new Error("Test Session cancelled")}),R.Call(()=>new Promise((t,E)=>T?t():d?t():(m&&(m.err=m.err?m.err.message?m.err.message:JSON.stringify(m.err):null,m.steps&&m.steps.forEach(e=>{e.err=e.err?e.err.message?e.err.message:JSON.stringify(e.err):null})),p.totalCount++,v?p.failedCount++:p.successCount++,null!==v&&o.bail&&h(c),void a("process.progress",{testSessionId:c,testSessionName:l,testSessionJobId:u,currentBatchIndex:S,batchNum:e,batchStart:n,batchEnd:r,batchLength:i,convosPerBatch:s,progress:Math.round((S-n+1)/i*100),testcase:g.header.name,source:g.toString(),sourceTag:g.sourceTag,transcript:m,attachments:f,success:null===v,err:v?v.message?v.message:JSON.stringify(v):null,stopTestSession:null!==v&&o.bail}).on("complete",t).on("failed",e=>{E(new Error(`process.progress finally failed after retry attempts: ${e}, decr redis counter`))}))))}R.Clean(),R.Exec().then(()=>m(p)).catch(e=>{R.container?(E(`Test Session Run failed (${e}), doing additional BotDriver Clean.`),R.container.Clean().catch(e=>E(e)).then(()=>{e.result=p,f(e)})):(E(`Test Session Run failed (${e}).`),f(e))})}).catch(f)}).then(e=>(I(),e)).catch(e=>{throw I(),e})},O=e=>{m[e]&&(m[e].forEach(e=>e()),delete m[e],E(`Worker for ${e} cancelled.`))},_=h;l.config(),p();const b=c("botium-box-worker"),R=(()=>{if(process.env.BOTIUMBOX_AGENT_NAME)return process.env.BOTIUMBOX_AGENT_NAME;const e=u.hostname();return e&&process.env.hasOwnProperty("BOTIUMBOX_AGENT_NUM")?`${e}_${process.env.BOTIUMBOX_AGENT_NUM}`:e||"Default Agent"})(),C=process.env.BOTIUMBOX_AGENT_GROUP||"Default Group";b(`Connecting agent ${R} to group ${C} ...`);let N={};if(process.env.BOTIUMBOX_QUEUE_SETTINGS)try{N=JSON.parse(process.env.BOTIUMBOX_QUEUE_SETTINGS),b(`Got queue settings '${JSON.stringify(N)}'`)}catch(e){console.log(`ERROR parsing queue settings '${process.env.BOTIUMBOX_QUEUE_SETTINGS}':`),console.log(e),process.exit(1)}else process.env.BOTIUMBOX_QUEUE_PREFIX&&(N.prefix=process.env.BOTIUMBOX_QUEUE_PREFIX),process.env.BOTIUMBOX_QUEUE_REDISURL&&(N.redis=process.env.BOTIUMBOX_QUEUE_REDISURL);b(`connecting to Botium queue '${JSON.stringify(N)}'`);const $=process.env.hasOwnProperty("BOTIUMBOX_QUEUE_PROGRESS_RETRY_ATTEMPTS")?process.env.BOTIUMBOX_QUEUE_PROGRESS_RETRY_ATTEMPTS:5,v=process.env.hasOwnProperty("BOTIUMBOX_QUEUE_PROGRESS_RETRY_DELAY")?process.env.BOTIUMBOX_QUEUE_PROGRESS_RETRY_DELAY:1e4;b(`Using job progress retryAttempts: ${$}, retryDelay: ${v}`);const P=process.env.BOTIUMBOX_QUEUE_CONCURRENCY||1;let U=process.env.BOTIUMBOX_QUEUE_HEARTBEAT||3e5;U>0&&U<5e3&&(U=5e3);const M=T.createQueue(N);M.on("error",e=>{console.log(`ERROR connecting to queue '${JSON.stringify(N)}':`),console.log(e),process.exit(1)});const y=(e,t)=>M.create(e,t).removeOnComplete(!0).save(),B=(e,t)=>M.create(e,t).attempts($).backoff({delay:v,type:"fixed"}).removeOnComplete(!0).save();let A={};const X=e=>{A=e};b("Trying to register agent ..."),y("agent.register",{title:`register agent ${R} to group ${C}`,name:R,group:C}).on("failed",e=>{console.log("ERROR registering agent:"),console.log(e),process.exit(1)}).on("complete",e=>{b(`Registration completed with result '${JSON.stringify(e)}', now accepting processing jobs (concurrency ${P}).`),X(e);const t=(e,t)=>{const{testSessionId:s,testSessionName:o,testSessionJobId:n}=e.data;if(!s||!n)return t(new Error(`Processing Job ${e.id} failed, no testSessionId or testSessionJobId given.`));b(`Processing Job ${e.id} for Test Session ${s}/${o}, Job ${n}`);try{I(A,e,B).then(r=>{b(`Processing Job ${e.id} finished with result:`),r&&b(r),t(null,r),B("process.ready.success",{title:`Processing Job ${e.id} for Test Session ${s}/${o} ready`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,result:r})}).catch(r=>{b(`Processing Job ${e.id} failed:`),b(r),t(r),B("process.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,result:r.result,err:`${r}`})})}catch(r){b(`Processing Job ${e.id} failed:`),b(r),t(r),B("process.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,err:r})}};if(M.process(`process.run.${C}`,P,t),M.process(`process.run.${R}`,P,t),M.process("process.run",P,t),M.process(`process.cancel.${R}`,P,(e,t)=>{if(!e.data||!e.data.testSessionId)return[b,t].forEach(e=>e("Cancel Test Session event received, but no testSessionId given"));b(`Canceling Test Session ${e.data.testSessionId}/${e.data.testSessionName}`);try{O(e.data.testSessionId),b(`Canceling Test Session ${e.data.testSessionId}/${e.data.testSessionName} finished.`),t()}catch(s){b(`Canceling Test Session Job ${e.data.testSessionId}/${e.data.testSessionName} failed:`),b(s),t(s)}}),M.process(`process.stop.${R}`,P,(e,t)=>{if(!e.data||!e.data.testSessionId)return[b,t].forEach(e=>e("Stop Test Session event received, but no testSessionId given"));b(`Stopping Test Session ${e.data.testSessionId}/${e.data.testSessionName}`);try{_(e.data.testSessionId),b(`Stopping Test Session ${e.data.testSessionId}/${e.data.testSessionName} finished.`),t()}catch(s){b(`Stopping Test Session Job ${e.data.testSessionId}/${e.data.testSessionName} failed:`),b(s),t(s)}}),M.process(`agent.ping.${R}`,P,(e,t)=>{t()}),M.process(`agent.reconfigure.${R}`,P,(e,t)=>{b("Trying to reconfigure agent ..."),y("agent.register",{title:`reconfigure agent ${R} for group ${C}`,name:R,group:C}).on("failed",e=>{b("ERROR reconfiguring agent:"),b(e),t(e)}).on("complete",e=>{b(`Reconfiguration completed with result '${JSON.stringify(e)}'.`),X(e),t()})}),U>0){const e=()=>{b("sending heartbeat ..."),y("agent.heartbeat",{title:`heartbeat from agent ${R} for group ${C}`,name:R,group:C}).on("complete",()=>{setTimeout(e,U)})};e()}}),process.on("uncaughtException",e=>{console.log("Got an uncaughtException",e)});return{}});
