!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("path"),require("slugify"),require("nodegit"),require("botium-core/src/scripting/Constants"),require("botium-core/src/Capabilities"),require("intercept-stdout"),require("util"),require("botium-core"),require("p-queue"),require("delay"),require("botium-core/src/Fluent"),require("debug"),require("dotenv-flow"),require("os"),require("kue")):"function"==typeof define&&define.amd?define(["path","slugify","nodegit","botium-core/src/scripting/Constants","botium-core/src/Capabilities","intercept-stdout","util","botium-core","p-queue","delay","botium-core/src/Fluent","debug","dotenv-flow","os","kue"],t):e.main=t(e.path,e.slugify,e.nodegit,e.Constants,e.Capabilities,e.interceptStdout,e.util,e.botiumCore,e.pQueue,e.delay,e.Fluent,e.debug,e.dotenvFlow,e.os,e.kue)}(this,function(e,t,s,o,n,r,a,i,c,l,d,u,p,T,m){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e,t=t&&t.hasOwnProperty("default")?t.default:t,s=s&&s.hasOwnProperty("default")?s.default:s,o=o&&o.hasOwnProperty("default")?o.default:o,n=n&&n.hasOwnProperty("default")?n.default:n,r=r&&r.hasOwnProperty("default")?r.default:r,a=a&&a.hasOwnProperty("default")?a.default:a,i=i&&i.hasOwnProperty("default")?i.default:i,c=c&&c.hasOwnProperty("default")?c.default:c,l=l&&l.hasOwnProperty("default")?l.default:l,d=d&&d.hasOwnProperty("default")?d.default:d,u=u&&u.hasOwnProperty("default")?u.default:u,p=p&&p.hasOwnProperty("default")?p.default:p,T=T&&T.hasOwnProperty("default")?T.default:T,m=m&&m.hasOwnProperty("default")?m.default:m;const f={buildTarget:"COMMUNITY EDITION",buildBranch:"release/1.6.0",buildRevision:"65ffaa3fe2442427262dae64218358ec4aa6105b",buildDate:"2019-05-23T15:52:34+02:00"};var S=()=>{console.log("BOTIUM BOX - AGENT"),console.log(`BUILD_TARGET: ${f.buildTarget}`),console.log(`BUILD_BRANCH: ${f.buildBranch}`),console.log(`BUILD_REVISION: ${f.buildRevision}`),console.log(`BUILD_TIMESTAMP: ${f.buildDate}`)};const g=u("botium-retrieve-all-test-cases");var I=(e,t,s)=>{e.convos&&e.convos.forEach(s=>{let n=[];try{s.format===o.SCRIPTING_FORMAT_TXT&&(n=t.Compile(s.content,o.SCRIPTING_FORMAT_TXT,o.SCRIPTING_TYPE_CONVO)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(t){throw g(t),new Error(`${e.name}: Convo Script compilation failed: ${a.inspect(t)}`)}}),e.pconvos&&e.pconvos.forEach(s=>{let n=[];try{s.format===o.SCRIPTING_FORMAT_TXT&&(n=t.Compile(s.content,o.SCRIPTING_FORMAT_TXT,o.SCRIPTING_TYPE_PCONVO)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(t){throw g(t),new Error(`${e.name}: Partial Convo Script compilation failed: ${a.inspect(t)}`)}}),e.utterances&&e.utterances.forEach(s=>{let n=[];try{s.format===o.SCRIPTING_FORMAT_TXT&&(n=t.Compile(s.content,o.SCRIPTING_FORMAT_TXT,o.SCRIPTING_TYPE_UTTERANCES)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(t){throw g(t),new Error(`${e.name}: Utterance script compilation failed: ${a.inspect(t)}`)}}),e.scriptingMemories&&e.scriptingMemories.forEach(s=>{let n=[];try{s.format===o.SCRIPTING_FORMAT_TXT&&(n=t.Compile(s.content,o.SCRIPTING_FORMAT_TXT,o.SCRIPTING_TYPE_SCRIPTING_MEMORY)),n&&n.forEach(e=>{e.sourceTag=s.sourceTag})}catch(t){throw g(t),new Error(`${e.name}: Scripting Memory script compilation failed: ${a.inspect(t)}`)}}),e.folders&&e.folders.forEach(s=>{try{const{convos:o,pconvos:n,utterances:r}=t.ReadScriptsFromDirectory(s.path,s.globFilter);o&&o.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)}),n&&n.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)}),r&&r.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,s.sourceTag)})}catch(t){throw g(t),new Error(`${e.name}: Folder ${s} script compilation failed: ${a.inspect(t)}`)}});let r=Promise.resolve();e.excels&&e.excels.length>0&&(r=Promise.all(e.excels.map(({id:e,filename:s,filecontent:r,hasConvos:a,hasPartialConvos:i,hasUtterances:c,worksheetsConvos:l,worksheetsPartialConvos:d,worksheetsUtterances:u,startRow:p,startCol:T,sourceTag:m})=>new Promise(e=>{const s=Buffer.from(r,"base64");let f=[],S=[],g=[];a&&(l&&(t.caps[n.SCRIPTING_XLSX_SHEETNAMES]=l),isNaN(p)||(t.caps[n.SCRIPTING_XLSX_STARTROW]=p),isNaN(T)||(t.caps[n.SCRIPTING_XLSX_STARTCOL]=T),f=t.Compile(s,o.SCRIPTING_FORMAT_XSLX,o.SCRIPTING_TYPE_CONVO)),i&&(d&&(t.caps[n.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]=d),isNaN(p)||(t.caps[n.SCRIPTING_XLSX_STARTROW]=p),isNaN(T)||(t.caps[n.SCRIPTING_XLSX_STARTCOL]=T),S=t.Compile(s,o.SCRIPTING_FORMAT_XSLX,o.SCRIPTING_TYPE_PCONVO)),c&&(u&&(t.caps[n.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]=u),isNaN(p)||(t.caps[n.SCRIPTING_XLSX_STARTROW]=p),isNaN(T)||(t.caps[n.SCRIPTING_XLSX_STARTCOL]=T),g=t.Compile(s,o.SCRIPTING_FORMAT_XSLX,o.SCRIPTING_TYPE_UTTERANCES)),f&&f.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),S&&S.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),g&&g.forEach(e=>{e.sourceTag=Object.assign({},e.sourceTag,m)}),e()}))));let i=Promise.resolve();return Promise.all([i,r])},h={prepareConvos:(e,t,s)=>{const o=e.testSets.filter(e=>e.expandConvos).length>0,n=e.testSets.filter(e=>e.expandUtterancesToConvos).length>0,r=e.testSets.filter(e=>e.expandScriptingMemory).length>0;return n&&(s("expanding utterances to convos ..."),t.compiler.ExpandUtterancesToConvos()),r&&(s("expanding scripting memories to convos ..."),t.compiler.ExpandScriptingMemoryToConvos()),(o||n||r)&&(s("expanding convos ..."),t.compiler.ExpandConvos()),s(`found ${t.compiler.convos.length} convos ...`),t.compiler.convos},merge:(e,t)=>{const s={};e.botium&&e.botium.Capabilities&&Object.assign(s,e.botium.Capabilities),t.botium&&t.botium.Capabilities&&Object.assign(s,t.botium.Capabilities);const o={};e.botium&&e.botium.Sources&&Object.assign(o,e.botium.Sources),t.botium&&t.botium.Sources&&Object.assign(o,t.botium.Sources);const n={};return e.botium&&e.botium.Envs&&Object.assign(n,e.botium.Envs),t.botium&&t.botium.Envs&&Object.assign(n,t.botium.Envs),{caps:s,sources:o,envs:n}}};const E=i.BotDriver,b=u("botium-box-worker-runtestcases"),{prepareConvos:$,merge:C}=h,O={},R={},v=e=>{R[e]&&(R[e].forEach(e=>e()),delete R[e],b(`Worker for ${e} stopped.`))};var N=(e,{id:t,data:s},o)=>{const{testSessionId:n,testSessionName:a,testSessionJobId:i}=s;let c=!1,l=!1;((e,t,s)=>{O[e]||(O[e]=[]),R[e]||(R[e]=[]),O[e].push(t),R[e].push(s)})(n,()=>{c=!0},()=>{l=!0});const d={unhook:null},u=()=>{d.unhook&&(d.unhook(),d.unhook=null)};return new Promise((u,p)=>{d.unhook=r(t=>{if(e.debug){const e=t.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,"");o("process.log",{testSessionId:n,testSessionName:a,testSessionJobId:i,log:e})}return t}),b(`Started processing, JobId #${t}.`);const{caps:T,sources:m,envs:f}=C(e,s),S=new E(T,m,f),g=S.BuildFluent();g.compiler=S.BuildCompiler(),S._validate().then(()=>new Promise((e,t)=>{Promise.all(s.testSets.map(e=>I(e,g.compiler,S.tempDirectory))).then(()=>$(s,g,b)).then(t=>{e(t.reduce((e,t)=>e.concat(t),[]))}).catch(t)})).then(()=>{const e=s.batchNum||1,t=s.batchCount||1,r=Math.ceil(g.compiler.convos.length/t),d=r*(e-1),T=Math.min(d+r,g.compiler.convos.length)-1,m=T-d+1,f={batchNum:e,totalCount:0,failedCount:0,successCount:0};b(`batchNum: ${e} batchCount: ${t} convosPerBatch: ${r} batchStart: ${d} batchEnd: ${T} batchLength: ${m}`);for(let t=d;t<=T;t++){const u=t,p=g.compiler.convos[u];let I=null;const h=[],E=(e,t)=>{t.attachments&&h.push(...t.attachments)},$=(e,t)=>{t.attachments&&h.push(...t.attachments)},C=(e,t)=>{h.push(t)},O=(e,t)=>{t&&(p.sourceTag=Object.assign({},p.sourceTag,t))},R=()=>{S.eventEmitter.removeListener("MESSAGE_SENTTOBOT",E),S.eventEmitter.removeListener("MESSAGE_RECEIVEDFROMBOT",$),S.eventEmitter.removeListener("MESSAGE_ATTACHMENT",C),S.eventEmitter.removeListener("CONTAINER_STARTED",O)},N=()=>{S.on("MESSAGE_SENTTOBOT",E),S.on("MESSAGE_RECEIVEDFROMBOT",$),S.on("MESSAGE_ATTACHMENT",C),S.on("CONTAINER_STARTED",O)};let _=null;g.Call(()=>{if(c)throw new Error("Test Session cancelled")}),g.Call(N).Start(),g.Call(()=>new Promise(e=>{if(c)b(`Test Session cancelled, skipping Convo "${p.header.name}", Index ${u}, ${u-d} from ${r}`),e();else if(l)b(`Test Session stopped, skipping Convo "${p.header.name}", Index ${u}, ${u-d} from ${r}`),e();else{b(`Running Convo "${p.header.name}", Index ${u}, ${u-d+1} from ${m}`);try{return p.Run(g.container).then(t=>{b(`Running Convo "${p.header.name}" completed successfully.`),I=t,e()}).catch(t=>{b(`Running Convo "${p.header.name}" failed: ${t}.`),I=t.transcript,_=t,e()})}catch(t){_=t,e()}}})),g.Stop().Call(R),g.Call(()=>{if(c)throw new Error("Test Session cancelled")}),g.Call(()=>new Promise((t,S)=>c?t():l?t():(I&&(I.err=I.err?I.err.message?I.err.message:JSON.stringify(I.err):null,I.steps&&I.steps.forEach(e=>{e.err=e.err?e.err.message?e.err.message:JSON.stringify(e.err):null})),f.totalCount++,_?f.failedCount++:f.successCount++,null!==_&&s.bail&&v(n),void o("process.progress",{testSessionId:n,testSessionName:a,testSessionJobId:i,currentBatchIndex:u,batchNum:e,batchStart:d,batchEnd:T,batchLength:m,convosPerBatch:r,progress:Math.round((u-d+1)/m*100),testcase:p.header.name,source:p.toString(),sourceTag:p.sourceTag,transcript:I,attachments:h,success:null===_,err:_?_.message?_.message:JSON.stringify(_):null,stopTestSession:null!==_&&s.bail}).on("complete",t).on("failed",e=>{S(new Error(`process.progress finally failed after retry attempts: ${e}, decr redis counter`))}))))}g.Clean(),g.Exec().then(()=>u(f)).catch(e=>{g.container?(b(`Test Session Run failed (${e}), doing additional BotDriver Clean.`),g.container.Clean().catch(e=>b(e)).then(()=>{e.result=f,p(e)})):(b(`Test Session Run failed (${e}).`),p(e))})}).catch(p)}).then(e=>(u(),e)).catch(e=>{throw u(),e})},_=e=>{O[e]&&(O[e].forEach(e=>e()),delete O[e],b(`Worker for ${e} cancelled.`))},P=v;const y=u("botium-box-worker-runperformancetestcases"),w=i.BotDriver,{prepareConvos:B,merge:U}=h,M={},A=({data:e,testState:t,tools:s})=>{const o=new Date,{botDriver:n,isCancelled:r}=s,a=new d(n);a.compiler=s.fluent.compiler,a.currentChannel=s.fluent.currentChannel;const i=a.compiler.convos[t.convoIndex];y(`Performance test executing Convo "${i.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`);let c=null,l=null;return new Promise((n,d)=>{a.Call(()=>{if(r())throw new Error("Test Session cancelled")}),a.Start().Call(()=>new Promise(s=>{if(!r())return i.Run(a.container).then(e=>{c=e,s()}).catch(e=>{y(`Running Convo "${i.header.name}" failed: ${e}.`),c=e.transcript,l=e,s()});y(`Performance test Session cancelled, skipping Convo "${i.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`),s()})).Stop(),a.Call(()=>{if(r())throw new Error("Test Session cancelled")}),a.Call(()=>new Promise((n,a)=>{if(r())return n();const d=c.steps.reduce((e,t)=>e+(t.botEnd.getTime()-t.botBegin.getTime()),0),u={performanceTestSessionId:e.performanceTestSessionId,performanceTestSessionName:e.performanceTestSessionName,performanceTestSessionJobId:e.performanceTestSessionJobId,convo:i.header.name||null,convoIndex:t.convoIndex,success:null===l,err:l?l.message?l.message:JSON.stringify(l):null,tick:t.tickIndex,repeat:t.repeat,runtime:d,queueBegin:t.queueBegin,testBegin:o,testEnd:new Date};y(`performanceprocess.progress: ${JSON.stringify(u)}.`),s.createJob("performanceprocess.progress",u).on("complete",n).on("failed",e=>{a(new Error(`performanceprocess.progress finally failed after retry attempts: ${e}, decr redis counter`))})})),a.Clean(),a.Exec().then(()=>{y(`Performance test executed Convo "${i.header.name}", Tick: ${t.tickIndex+1}/${e.tickCount}, Repeat: ${t.repeat+1}/${t.maxRepeat}, Convo: ${t.convoIndex}`),n()}).catch(e=>{y(`Performance Test Session Run failed (${e}), doing additional BotDriver Clean.`),a.Clean().Exec().catch(e=>y(e)).then(()=>{d(e)})})})};var J=(e,{created_at:t,id:s,data:o,_attempts:n},r)=>{const{testSessionId:i}=o;let d=!1;((e,t)=>{M[e]||(M[e]=[]),M[e].push(t)})(i,()=>{d=!0});const u=()=>d;y(`Started processing, JobId #${s} Data: ${a.inspect(o)}.`);const{caps:p,sources:T,envs:m}=U(e,o),f=new w(p,T,m),S=f.BuildFluent();return S.compiler=f.BuildCompiler(),f._validate().then(()=>new Promise((e,t)=>{Promise.all(o.testSets.map(e=>I(e,S.compiler,f.tempDirectory))).then(()=>B(o,S,y)).then(t=>{e(t.reduce((e,t)=>e.concat(t),[]))}).catch(t)})).then(()=>{S.compiler.ExpandConvos();const e=new c({concurrency:o.parallelConvoCount||20});return o.tickCount=Math.floor(o.tickMaxTime/o.tickTime+1),(async({jobId:e,data:t,tools:s})=>{y(`mainQueueFeeder JobId #${e}`);const o=({jobId:e,data:t,tickIndex:s,tools:o})=>{const{fluent:n,queue:r}=o,i=t.tickRepeatInitial+t.tickRepeatPerTick*s;y(`tickQueueFeederAsync JobId #${e} tickIndex ${s} repeats ${i}.`);for(let e=0;e<i;e++)for(let a=0;a<n.compiler.convos.length;a++){const n=new Date;r.add(()=>A({data:t,testState:{convoIndex:a,tickIndex:s,maxRepeat:i,repeat:e,queueBegin:n},tools:o}))}const{performanceTestSessionId:c,performanceTestSessionJobId:l,performanceTestSessionName:d}=t,u={performanceTestSessionId:c,performanceTestSessionName:d,performanceTestSessionJobId:l,addedInTick:i,tickIndex:s,executing:o.queue.pending,waiting:o.queue.size};y(`Tick ${a.inspect(u)}`)};for(let n=0;n<t.tickCount;n++)await o({jobId:e,data:t,tickIndex:n,tools:s}),await l(t.tickTime);await(e=>new Promise((t,s)=>{e.onIdle().then(()=>{t()})}))(s.queue),y(`mainQueueFeeder JobId #${e} finished`)})({jobId:s,data:o,tools:{createJob:r,botDriver:f,fluent:S,queue:e,isCancelled:u},queueBegin:new Date(Number(t))})})},x=(e,t)=>{M[e]&&(M[e].forEach(e=>e()),delete M[e])};p.config(),S();const X=u("botium-box-worker"),G=(()=>{if(process.env.BOTIUMBOX_AGENT_NAME)return process.env.BOTIUMBOX_AGENT_NAME;const e=T.hostname();return e&&process.env.hasOwnProperty("BOTIUMBOX_AGENT_NUM")?`${e}_${process.env.BOTIUMBOX_AGENT_NUM}`:e||"Default Agent"})(),k=process.env.BOTIUMBOX_AGENT_GROUP||"Default Group";X(`Connecting agent ${G} to group ${k} ...`);let D={};if(process.env.BOTIUMBOX_QUEUE_SETTINGS)try{D=JSON.parse(process.env.BOTIUMBOX_QUEUE_SETTINGS),X(`Got queue settings '${JSON.stringify(D)}'`)}catch(e){console.log(`ERROR parsing queue settings '${process.env.BOTIUMBOX_QUEUE_SETTINGS}':`),console.log(e),process.exit(1)}else process.env.BOTIUMBOX_QUEUE_PREFIX&&(D.prefix=process.env.BOTIUMBOX_QUEUE_PREFIX),process.env.BOTIUMBOX_QUEUE_REDISURL&&(D.redis=process.env.BOTIUMBOX_QUEUE_REDISURL);X(`connecting to Botium queue '${JSON.stringify(D)}'`);const q=process.env.hasOwnProperty("BOTIUMBOX_QUEUE_PROGRESS_RETRY_ATTEMPTS")?process.env.BOTIUMBOX_QUEUE_PROGRESS_RETRY_ATTEMPTS:5,L=process.env.hasOwnProperty("BOTIUMBOX_QUEUE_PROGRESS_RETRY_DELAY")?process.env.BOTIUMBOX_QUEUE_PROGRESS_RETRY_DELAY:1e4;X(`Using job progress retryAttempts: ${q}, retryDelay: ${L}`);const F=process.env.BOTIUMBOX_QUEUE_CONCURRENCY||1,j=process.env.BOTIUMBOX_QUEUE_CONCURRENCY_PERFORMANCE||1;let Q=process.env.BOTIUMBOX_QUEUE_HEARTBEAT||3e5;Q>0&&Q<5e3&&(Q=5e3);const Y=m.createQueue(D);Y.on("error",e=>{console.log(`ERROR connecting to queue '${JSON.stringify(D)}':`),console.log(e),process.exit(1)});const V=(e,t)=>Y.create(e,t).removeOnComplete(!0).save(),H=(e,t)=>Y.create(e,t).attempts(q).backoff({delay:L,type:"fixed"}).removeOnComplete(!0).save();let W={};const z=e=>{W=e};X("Trying to register agent ..."),V("agent.register",{title:`register agent ${G} to group ${k}`,name:G,group:k}).on("failed",e=>{console.log("ERROR registering agent:"),console.log(e),process.exit(1)}).on("complete",e=>{X(`Registration completed with result '${JSON.stringify(e)}', now accepting processing jobs (concurrency ${F}, concurrencyPerformance, ${j}).`),z(e);const t=(e,t)=>{const{testSessionId:s,testSessionName:o,testSessionJobId:n}=e.data;if(!s||!n)return t(new Error(`Processing Job ${e.id} failed, no testSessionId or testSessionJobId given.`));X(`Processing Job ${e.id} for Test Session ${s}/${o}, Job ${n}`);try{N(W,e,H).then(r=>{X(`Processing Job ${e.id} finished with result:`),r&&X(r),t(null,r),H("process.ready.success",{title:`Processing Job ${e.id} for Test Session ${s}/${o} ready`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,result:r})}).catch(r=>{X(`Processing Job ${e.id} failed:`),X(r),t(r),H("process.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,result:r.result,err:`${r}`})})}catch(r){X(`Processing Job ${e.id} failed:`),X(r),t(r),H("process.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,testSessionId:s,testSessionName:o,testSessionJobId:n,jobId:e.id,err:r})}};if(Y.process(`process.run.${k}`,F,t),Y.process(`process.run.${G}`,F,t),Y.process("process.run",F,t),Y.process(`process.cancel.${G}`,F,(e,t)=>{if(!e.data||!e.data.testSessionId)return[X,t].forEach(e=>e("Cancel Test Session event received, but no testSessionId given"));X(`Canceling Test Session ${e.data.testSessionId}/${e.data.testSessionName}`);try{_(e.data.testSessionId),X(`Canceling Test Session ${e.data.testSessionId}/${e.data.testSessionName} finished.`),t()}catch(s){X(`Canceling Test Session Job ${e.data.testSessionId}/${e.data.testSessionName} failed:`),X(s),t(s)}}),Y.process(`process.stop.${G}`,F,(e,t)=>{if(!e.data||!e.data.testSessionId)return[X,t].forEach(e=>e("Stop Test Session event received, but no testSessionId given"));X(`Stopping Test Session ${e.data.testSessionId}/${e.data.testSessionName}`);try{P(e.data.testSessionId),X(`Stopping Test Session ${e.data.testSessionId}/${e.data.testSessionName} finished.`),t()}catch(s){X(`Stopping Test Session Job ${e.data.testSessionId}/${e.data.testSessionName} failed:`),X(s),t(s)}}),Y.process(`agent.ping.${G}`,F,(e,t)=>{t()}),Y.process("performanceprocess.run",j,(e,t)=>{const{performanceTestSessionId:s,performanceTestSessionName:o,performanceTestSessionJobId:n}=e.data;if(!s||!n)return t(new Error(`Processing Job ${e.id} failed, no performanceTestSessionId or performanceTestSessionJobId given.`));X(`Processing Job ${e.id} for Test Session ${s}/${o}, Job ${n}`);try{H("performanceprocess.started",{title:`Processing Job ${e.id} for Test Session ${s}/${o} started`,performanceTestSessionId:s,performanceTestSessionName:o,performanceTestSessionJobId:n,agentName:G,jobId:e.id}),J(W,e,H).then(r=>{X(`Processing Job ${e.id} finished`),t(null,r),H("performanceprocess.ready.success",{title:`Processing Job ${e.id} for Test Session ${s}/${o} ready`,performanceTestSessionId:s,performanceTestSessionName:o,performanceTestSessionJobId:n,agent:G,jobId:e.id,result:r})}).catch(r=>{X(`Processing Job ${e.id} failed:`),X(r),t(r),H("performanceprocess.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,performanceTestSessionId:s,performanceTestSessionName:o,performanceTestSessionJobId:n,agent:G,jobId:e.id,result:r.result,err:`${r}`})})}catch(r){X(`Processing Job ${e.id} failed:`),X(r),t(r),H("performanceprocess.ready.failed",{title:`Processing Job ${e.id} for Test Session ${s}/${o} failed`,performanceTestSessionId:s,performanceTestSessionName:o,performanceTestSessionJobId:n,agent:G,jobId:e.id,err:r})}}),Y.process(`performanceprocess.cancel.${G}`,j,(e,t)=>{if(!e.data||!e.data.performanceTestSessionId)return[X,t].forEach(e=>e("Cancel Test Session event received, but no performanceTestSessionId given"));X(`Canceling Test Session ${e.data.performanceTestSessionId}/${e.data.performanceTestSessionName}`);try{x(e.data.performanceTestSessionId,e),X(`Canceling Test Session ${e.data.performanceTestSessionId}/${e.data.performanceTestSessionName} finished.`),t()}catch(s){X(`Canceling Test Session Job ${e.data.performanceTestSessionId}/${e.data.performanceTestSessionName} failed:`),X(s),t(s)}}),Y.process(`agent.reconfigure.${G}`,F,(e,t)=>{X("Trying to reconfigure agent ..."),V("agent.register",{title:`reconfigure agent ${G} for group ${k}`,name:G,group:k}).on("failed",e=>{X("ERROR reconfiguring agent:"),X(e),t(e)}).on("complete",e=>{X(`Reconfiguration completed with result '${JSON.stringify(e)}'.`),z(e),t()})}),Q>0){const e=()=>{X("sending heartbeat ..."),V("agent.heartbeat",{title:`heartbeat from agent ${G} for group ${k}`,name:G,group:k}).on("complete",()=>{setTimeout(e,Q)})};e()}}),process.on("uncaughtException",e=>{console.log("Got an uncaughtException",e)});return{}});
